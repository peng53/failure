<html>
<head>
<style>
	#mines {
		position: absolute;
		top: 0;
		bottom: 0;
		left: 0;
		right: 0;
		margin: auto;
		border: 1px solid black;
	}
</style>
</head>
<body>
<canvas
	id='mines'
	width='500px'
	height='500px'
	data-cellsize=20
	data-nmines=10
></canvas>
</body>
<script src='queue.js'></script>
<script>
	'use strict';
	/* primative internals */
	function Mines2d(cols, rows){
		this.A = new Array(rows);
		for (let r=0; r<rows; ++r){
			this.A[r] = new Array(cols);
			arrSetValues(this.A[r], 0);
		}
		this.cols = cols;
		this.rows = rows;
		this.plantMine = function(r,c){
			this.A[r][c] = 9;
			this.plantWarning(r-1,c-1);
			this.plantWarning(r-1,c);
			this.plantWarning(r-1,c+1);
			this.plantWarning(r,c-1);
			this.plantWarning(r,c+1);
			this.plantWarning(r+1,c-1);
			this.plantWarning(r+1,c);
			this.plantWarning(r+1,c+1);
		};
		this.plantWarning = function(r,c){
			if (r>=0 && r<this.rows && c>=0 && c<this.cols && this.A[r][c] !== 9){
				++this.A[r][c];
			}
		};
	}
	function arrSetValues(arr, val){
		for (let i=arr.length-1; i>=0; --i){
			arr[i] = val;
		}
	}

	function Scanline(x0,x1,r){
		this.x0 = x0;
		this.x1 = x1;
		this.r = r;
	}
	function expandScanline(line, fl, matching){
		// expands line left and right to matching vals
		let r = line.r, i = line.x0, j = line.x1;
		while (i>0 && fl.A[r][i-1]==matching){
			--i;
		}
		line.x0 = i;
		while (j<fl.rows-1 && fl.A[r][j+1]==matching){
			++j;
		}
		line.x1 = j;
		return line;
	}
	function revealScanlineSides(line, field, mcell, moff){
		// reveals the left and right sides of a scanline.
		let r = line.r, i = line.x0, j = line.x1;
		if (i > 0){
			revealNumber(r, i-1, field, mcell, moff);
		}
		if (j+1 < field.cols){
			revealNumber(r, j+1, field, mcell, moff);
		}
	}
function floodFill(fl, row, col, matching){
	let q = new Queue();
	q.put(expandScanline(new Scanline(col,col,row),fl,matching));
	let r,c0,c1,line;
	let t0, t1, b0, b1;
	let tl = false, bl = false;
	while (q.len > 0){
		line = q.get();
		r = line.r, c0 = line.x0, c1 = line.x1;
		revealScanlineSides(line, fl, mcell, moff);
		for (;c0<=c1;++c0){
			revealNumber(r,c0,fl,mcell,moff);
			fl.A[r][c0] = 'c';
			if (r>0){
				if (fl.A[r-1][c0]==matching){
					if (!tl){
						tl = true;
						t0 = t1 = c0;
					} else if (t1+1==c0){
						++t1;
					} else {
						q.put(expandScanline(new Scanline(t0,t1,r-1),fl,matching));
						t0 = t1 = c0;
					}
				} else {
					revealNumber(r-1,c0,fl,mcell,moff);
					//fl.A[r-1][c0] = 'c';
				}
			}
			if (r<fl.rows-1){
				if (fl.A[r+1][c0]==matching){
					if (!bl){
						bl = true;
						b0 = b1 = c0;
					} else if (b1+1==c0){
						++b1;
					} else {
						q.put(expandScanline(new Scanline(b0,b1,r+1),fl,matching));
						b0 = b1 = c0;
					}
				} else {
					revealNumber(r+1,c0,fl,mcell,moff);
					//fl.A[r+1][c0] = 'c';
				}
			}
		}
		if (tl){
			q.put(expandScanline(new Scanline(t0,t1,r-1),fl,matching));
			tl = false;
		}
		if (bl){
			q.put(expandScanline(new Scanline(b0,b1,r+1),fl,matching));
			bl = false;
		}
	}
}

function analyzeArray(){
	let d = {};
	let v;
	let m = 0;
	for (let i=ANALYZEARRAY.length-1; i>=0; --i){
		v = ANALYZEARRAY[i].toString();
		if (d[v] === undefined){
			d[v] = 1;
		} else {
			d[v]++;
		}
		m = Math.max(m, d[v]);
	}
	console.log(d,m);
	
}

function fill2(field, row, col, mcell, moff){
	ANALYZEARRAY = [];
	let q = new Queue();
	q.put(expandScanline(new Scanline(col,col,row),field,0));
	while (q.len > 0){
		fillh(field, q, mcell, moff);
	}
	
	
	/* ANALYZEARRAY NOT PART OF ALGO */
	analyzeArray();
}

function fillh(field, q, mcell, moff){
	let line = q.get();
	ANALYZEARRAY.push(['reveal0',line.r,line.x0,line.x1]);
	console.log('got line', line.r, line.x0, line.x1);
	let i = line.x0, j = line.x1, r = line.r;
	console.log('reveal: ', r, i, j);
	for (let k = i; k<=j; ++k){ // line[i..j] is known to be a sequence of 0s
		revealNumber(r,k,field,mcell,moff);
	}
	checkLine(field, r-1, i, j, q, mcell, moff);
	checkLine(field, r+1, i, j, q, mcell, moff);
}

	function drawSquare(row, col, cellSize, cellOff){
		let x = cellSize * col;
		let y = cellSize * row;
		ctx.alpha = 0.10;
		ctx.fillRect(x,y,cellOff,cellOff);
	}

function checkLine(field, row, start, stop, q, mcell, moff){
	if (row<0 || row>=field.rows){
		return;
	}
	ANALYZEARRAY.push(['tocheck',row,start,stop]);
	// for use with lines above/below 0 sequences.
	ctx.fillStyle = 'red';
	for (let i = start; i<=stop; ++i){
		drawSquare(row, i, mcell, moff);
	}
	ctx.fillStyle = 'blue';
	while (start-1>=0 && field.A[row][start-1]==0){
		--start;
		drawSquare(row, start, mcell, moff);
	}
	while (stop+1<field.cols && field.A[row][stop+1]==0){
		++stop;
		drawSquare(row, stop, mcell, moff);
	}
	let i;
	ctx.fillStyle = 'green';
	while (start<=stop){
		// two cases:
		if (field.A[row][start]==0){
			for (i = start; i<=stop && field.A[row][i]==0; ++i){
				drawSquare(row, i, mcell, moff);
				continue;
			}
			console.log('before put', q.len);
			q.put(new Scanline(start,i,row));
			start = i;
			console.log('after put', q.len);
		} else {
			while (start<=stop && field.A[row][i]!=0 && field.A[row][i]!='c'){
				revealNumber(row,start,field,mcell,moff);
				++start;
			}
		}
		start++;
	}
}


function revealRun(field, row, leftBound, rightBound, mcell, moff){
	for (; leftBound <= rightBound && field.A[row][leftBound] != 0; leftBound++){
		revealNumber(row,leftBound,field,mcell,moff);
	}
	console.log('returning bound of', leftBound, rightBound, row);
	return leftBound;
}

</script>

<script>
	'use strict';
	/* data setup */
	// Durstenfeld' shuffle
	function shuffleArray(A){
		let j,tempValue;
		for (let i=A.length-1; i>0; --i){
			j = Math.floor(Math.random()*i);
			tempValue = A[j];
			A[j] = A[i];
			A[i] = tempValue;
		}
	}
	function setupMinefield(cols, rows, mineCt){
		let mineLocLen = cols*rows;
		if (mineLocLen <= mineCt){
			alert('# of mines is equal or greater than dimensions');
			return;
		}
		let mineLoc = new Array(mineLocLen);
		// mineLoc is an Array of mine's priority
		for (let i=0; i<mineLoc.length; ++i){
			mineLoc[i] = i;
		}
		shuffleArray(mineLoc);
		let mfield = new Mines2d(cols, rows);
		let r, c;
		for (let i=0; i<mineCt; ++i){
			r = Math.floor(mineLoc[i] / cols);
			c = mineLoc[i] % cols;
			mfield.plantMine(r,c);
		}
		
		return mfield;
	}
</script>

<script>
	'use strict';
	/* drawing */
	function drawTileLines(width,height, mcell){
		ctx.strokeStyle = 'blue';
		for (let x=mcell; x<width; x+=mcell){
			ctx.moveTo(x,0);
			ctx.lineTo(x,height);
		}
		for (let y=mcell; y<height; y+=mcell){
			ctx.moveTo(0,y);
			ctx.lineTo(width,y);
		}
		ctx.stroke();
	}
	function revealNumber(row, col, mfield, cellSize, cellOff){
		let t = mfield.A[row][col];
		if (t=='c'){
			return;
		}
		let x = cellSize * col;
		let y = cellSize * row;
		let colors = ['#bbb','#aaa','#999','#888','#777','#666','#444','#333','#111','#000'];
		ctx.fillStyle = colors[t];
		if (t == 9){
			t = 'M';
		}
		ctx.fillText(t, x+cellOff, y+cellOff, cellSize);
		mfield.A[row][col] = 'c';
	}
	/* ui interaction */
	function floodReveal(r,c,mfield,cellSize,cellOff){
		// needs same args as the function(s) it calls..
		revealNumber(r,c,myfield,cellSize,cellOff);
		//floodFill(myfield,r,c,0);
		fill2(myfield, r, c, mcell, moff);
	}
	function getCursorPosition(canvas, event) {
		const rect = canvas.getBoundingClientRect();
		const x = event.clientX - rect.left;
		const y = event.clientY - rect.top;
		touchCanvas(x,y);
	}
	function touchCanvas(x, y){
		// myfield,mcell, and moff needs to be in an accessible location.
		let c = Math.floor(x/mcell);
		let r = Math.floor(y/mcell);
		if (c < myfield.cols && r < myfield.rows){
			if (myfield.A[r][c] == 0){
				floodReveal(r,c,myfield,mcell,moff);
			} else if (myfield.A[r][c] == 'c'){
			} else {
				revealNumber(r,c,myfield,mcell,moff);
			}
		}
	}
</script>

<script>
	'use strict';
	
	var ANALYZEARRAY = [];
	
	const can = document.getElementById('mines');
	const ctx = can.getContext('2d');

	const mcell = Number(can.dataset.cellsize); // size of graphical cell in pixels
	const mwidth = can.width-(can.width%mcell);
	const mheight = can.height-(can.height%mcell);
	
	const moff = mcell/2; // offset to center of cell
	const mcount = Number(can.dataset.nmines);
	let myfield = setupMinefield(mwidth/mcell, mheight/mcell, mcount);
	can.addEventListener('mousedown', function(e) {
		getCursorPosition(can, e);
	});

	ctx.font = mcell.toString()+'px monospace';
	ctx.textAlign = 'center';
	ctx.textBaseline = 'middle';

	drawTileLines(mwidth,mheight,mcell);

</script>

</html>