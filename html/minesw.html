<html>
<head>
<style>
	body {
		margin: 0;
	}
	canvas {
		position: absolute;
		top: 0;
		bottom: 0;
		left: 0;
		right: 0;
		margin: auto;
		border: 1px solid grey;
		image-rendering: crisp-edges;
		
		width: 300px;
		height: 300px;
		
	}
	#mines {
		z-index: -2;
	}
	#osd {
		z-index: -1;
		
	}
	#menu {
		margin: 0;
		padding: 0;
	}
	#menu button, #menu input{
		border: 0;
		float: left;
	}
	#menu button:hover {
		background: yellow;
	}
	#mtable {
		border: 1px orange solid;
		border-collapse: collapse;
		float: left;
	}
	#mtable td {
		font: 2em monospace;
		background: beige;
		width: 1em;
		height: 1em;
		text-align: center;
	}
	#mtable td:hover {
		background: cyan;
	}
</style>
</head>
<body>
<div id='menu'>
<button onclick='clearField()'>Clear</button>
<button onclick='revealField()'>RevealAll</button>
<input id='minecount' type='number' value=10 size=4 />
<button onclick='remine()'>Re-Mine</button>
<button onclick='osd.focus()'>Refocus</button>
<button onclick='mtable.style.display = "block";'>Enable Table</button>
</div>
<canvas
	id='mines'
	width='200px'
	height='200px'
	data-cellsize=20
	data-nmines=5
></canvas><canvas
	id='osd'
	width='200px'
	height='200px'
	tabindex= 1
></canvas>
<br>
<table id='mtable' data-rows=10 data-cols=10 data-mines=10 style='display:none'></table>
</body>
<script src='queue.js'></script>
<script>
	'use strict';
	/* primative internals */
	function Mines2d(cols, rows, cellSize){
		this.A = RectArray(rows,cols, 0);
		this.visible = RectArray(rows,cols, false);
		this.cols = cols;
		this.rows = rows;
		this.cellSize = cellSize;

		this.plantMine = function(r,c){
			this.A[r][c] = 9;
			let notTop = r>0, notLeft = c>0, notRight = c<this.cols, notBottom = r+1<this.rows;
			if (notTop){
				this.plantWarning(r-1,c);
				if (notLeft) this.plantWarning(r-1,c-1);
				if (notRight) this.plantWarning(r-1,c+1);
			}
			if (notBottom){
				this.plantWarning(r+1,c);
				if (notLeft) this.plantWarning(r+1,c-1);
				if (notRight) this.plantWarning(r+1,c+1);
			}
			if (notLeft) this.plantWarning(r,c-1);
			if (notRight) this.plantWarning(r,c+1);
		};

		this.plantWarning = function(r,c){
			if (this.A[r][c] !== 9){
				++this.A[r][c];
			}
		};
	}
	
	function ZeroLine(field, row, start, end){
		this.mf = field;
		this.r = row;
		this.c0 = start;
		this.c1 = (end===undefined) ? start : end;
		
		this.expand = function(match, adj){
			// Expands scanline on both sides.
			for (; this.c0-1>=0 && this.mf.A[this.r][this.c0-1] == match; --this.c0){
				continue;
			}
			for (; this.c1+1<this.mf.cols && this.mf.A[this.r][this.c1+1] == match; ++this.c1){
				continue;
			}
			return this;
		};
		this.reveal = function(revealEnds){
			// Reveals all tiles of this scanline.
			if (this.mf.visible[this.r][this.c]) return;
			const y = this.mf.cellSize * this.r;
			const offset = this.mf.cellSize/2;
			ctx.fillStyle = mineNumberColors[0];
			let x = this.mf.cellSize * this.c0;
			for (let c=this.c0; c<=this.c1; ++c){
				ctx.fillRect(x,y,this.mf.cellSize,this.mf.cellSize);
				ctx.strokeText('0', x+offset, y+offset, this.mf.cellSize);
				x += this.mf.cellSize;
				this.mf.visible[this.r][c] = true;
			}
			if (revealEnds){
				if (this.c0>0) revealNumber(this.r,this.c0-1);
				if (this.c1+1<this.mf.cols) revealNumber(this.r,this.c1+1);
			}
		};
	}

	function getZeroLines(field, r, c0, c1, ifnot, out){
		if (r<0 || r>=field.rows) return;
		let start, end;
		for (let c=c0; c<=c1; ++c){
			if (field.visible[r][c]) continue;
			if (field.A[r][c] != 0){
				ifnot(r,c);
			} else {
				if (start === undefined){
					start = end = c;
				} else if (end+1==c){
					++end;
				} else {
					out.push(new ZeroLine(field, r, start, end));
					start = end = c;
				}
			}
		}
		if (end){
			out.push(new ZeroLine(field, r, start, end));
		}
	}


	function revealNumber(row, col){
		if (!myfield.visible[row][col]){
			const x = myfield.cellSize * col;
			const y = myfield.cellSize * row;
			const offset = myfield.cellSize/2;
			const t = myfield.A[row][col];
			drawSquareTile(row, col, mineNumberColors[t]);
			ctx.strokeText(t==9? 'M' : t, x+offset, y+offset, myfield.cellSize);
			myfield.visible[row][col] = true;
		}
	}

	function RectArray(rows, cols, v){
		const a = new Array(rows);
		for (let r = 0; r<rows; ++r){
			a[r] = ArrayWithValue(cols,v);
		}
		return a;
	}
	
	function ArrayWithValue(size, val){
		const a = new Array(size);
		for (let i=0;i<size;++i){
			a[i]=val;
		}
		return a;
	}
	

</script>

<script>
	'use strict';
	/* data setup */
	// Durstenfeld' shuffle
	function shuffleArray(A){
		let j,tempValue;
		for (let i=A.length-1; i>0; --i){
			j = Math.floor(Math.random()*i);
			tempValue = A[j];
			A[j] = A[i];
			A[i] = tempValue;
		}
	}
	function setupMinefield(mfield, mineCt){
		const mineLocLen = mfield.cols*mfield.rows;
		if (mineLocLen <= mineCt){
			alert('# of mines is equal or greater than dimensions');
			return;
		}
		const mineLoc = new Array(mineLocLen);
		// mineLoc is an Array of mine's priority
		for (let i=0; i<mineLoc.length; ++i){
			mineLoc[i] = i;
		}
		shuffleArray(mineLoc);
		
		let r, c;
		for (let i=0; i<mineCt; ++i){
			r = Math.floor(mineLoc[i] / mfield.cols);
			c = mineLoc[i] % mfield.cols;
			mfield.plantMine(r,c);
		}
	}
</script>

<script>
	'use strict';
	/* drawing */
	function drawTileLines(width,height,mcell,color){
		const t = ctx.strokeStyle;
		ctx.strokeStyle = color;
		for (let x=mcell; x<width; x+=mcell){
			ctx.moveTo(x,0);
			ctx.lineTo(x,height);
		}
		for (let y=mcell; y<height; y+=mcell){
			ctx.moveTo(0,y);
			ctx.lineTo(width,y);
		}
		ctx.stroke();
		ctx.strokeStyle = t;
	}
	function revealNumber(row, col){
		if (!myfield.visible[row][col]){
			const x = myfield.cellSize * col;
			const y = myfield.cellSize * row;
			const offset = myfield.cellSize/2;
			const t = myfield.A[row][col];
			drawSquareTile(row, col, mineNumberColors[t]);
			ctx.strokeText(t==9? 'M' : t, x+offset, y+offset, myfield.cellSize);
			myfield.visible[row][col] = true;
		}
	}
	function drawSquareTile(row, col, color){
		const x = myfield.cellSize * col;
		const y = myfield.cellSize * row;
		ctx.fillStyle = color;
		ctx.fillRect(x,y,myfield.cellSize,myfield.cellSize);
	}
	/* ui interaction */
	function getCursorPosition(canvas, event) {
		const rect = canvas.getBoundingClientRect();
		const x = event.clientX - rect.left;
		const y = event.clientY - rect.top;
		console.log(x,y);
		if (window.event.ctrlKey){
			XYtoCRcall(x,y, function(c, r){
				myfield.plantMine(r,c);
			});
		} else {
			XYtoCRcall(x,y, function(c, r){
				touchCanvas(r,c)
			});
		}
	}
	function XYtoCRcall(x,y,f){
		const sx = can.clientWidth/can.width;
		const sy = can.clientHeight/can.height;
		const c = Math.floor(x/(myfield.cellSize*sx));
		const r = Math.floor(y/(myfield.cellSize*sy));
		if (c < myfield.cols && r < myfield.rows){
			f(c,r);
		}
	}
	function touchCanvas(r,c){
		osdSelection.clear();
		osdSelection.r = r;
		osdSelection.c = c;
		osdSelection.sq();
		if (myfield.visible[r][c]){
			return;
		}
		if (myfield.A[r][c] == 0){
			floodReveal(r,c);
		} else {
			revealNumber(r,c);
		}
	}

	function floodReveal(row, col){
		// Reveal tiles around row, col- which is known to be not visible and a 0.
		//let q = new NaiveQueue();
		let q = new Queue();
		let s;
		q.push(new ZeroLine(myfield, row, col, col));
		while (q.len>0){
			s = q.get();
			s.expand(0);
			s.reveal(true);
			getZeroLines(myfield,s.r-1,s.c0,s.c1,revealNumber,q);
			getZeroLines(myfield,s.r+1,s.c0,s.c1,revealNumber,q);
		}
	}

	function clearField(){
		ctx.clearRect(0,0,can.width,can.height);
		myfield.A = RectArray(myfield.rows,myfield.cols, 0);
		myfield.visible = RectArray(myfield.rows,myfield.cols, false);
		drawTileLines(mwidth,mheight,cellSize,'green');
	}
	function revealField(){
		for (let r=0;r<myfield.rows;++r){
			for (let c=0;c<myfield.cols;++c){
				revealNumber(r,c);
			}
		}
	}
	function remine(){
		clearField();
		setupMinefield(myfield, Number(minecount.value));
		osd.focus();
	}
	
	/* osd stuff */
	function OsdSelection(rows, cols){
		this.mr = rows;
		this.mc = cols;
		this.r = 0;
		this.c = 0;
		this.sq = function(){
			const x = myfield.cellSize * this.c;
			const y = myfield.cellSize * this.r;
			octx.fillRect(x,y,myfield.cellSize,myfield.cellSize);
		};
		this.clear = function(){
			octx.clearRect(myfield.cellSize*this.c,myfield.cellSize*this.r,myfield.cellSize,myfield.cellSize);
		};
	}
	function osdKeys(ev){
		const key = ev.key;
		if (key == 'ArrowRight'){
			osdSelection.clear();
			osdSelection.c = (osdSelection.c+1)%osdSelection.mc;
			osdSelection.sq();
		} else if (key == 'ArrowLeft'){
			osdSelection.clear();
			osdSelection.c = (osdSelection.c-1>=0) ? osdSelection.c-1 : osdSelection.mc-1;
			osdSelection.sq();
		} else if (key == 'ArrowDown'){
			osdSelection.clear();
			osdSelection.r = (osdSelection.r+1)%osdSelection.mr;
			osdSelection.sq();
		} else if (key == 'ArrowUp'){
			osdSelection.clear();
			osdSelection.r = (osdSelection.r-1>=0) ? osdSelection.r-1 : osdSelection.mr-1;
			osdSelection.sq();
		} else if (key == 'Enter'){
			touchCanvas(osdSelection.r,osdSelection.c);
		} else if (key == 'r'){
			remine();
		}
	}
	
	function drawState(field){
		// draws the current state of the field.
		drawTileLines(mwidth,mheight,cellSize,'green');
		let x, y =0, t, offset = field.cellSize/2;
		y = 0;
		ctx.strokeStyle = 'white';
		for (let r=0; r<field.rows; ++r){
			x = 0;
			for (let c=0; c<field.cols; ++c){
				if (field.visible[r][c]){
					t = field.A[r][c];
					ctx.fillStyle = mineNumberColors[t];
					ctx.fillRect(x,y,field.cellSize,field.cellSize);
					ctx.strokeText((t==9) ? 'M' : t, x+offset, y+offset, field.cellSize);
				}
				x += field.cellSize;
			}
			y += field.cellSize;
		}
	}
	function setTableTileStates(field){
		for (let r=0;r<field.rows;++r){
		}
	}
	function createTableRow(row, cols, rowNumber){
		let col;
		for (let i=0;i<cols;++i){
			col = row.insertCell(-1);
			col.append(document.createTextNode('?'));
			col.onclick = function(event){sayRowCol(rowNumber,i,event.target)};
		}
		return row;
	}
	function fillTableWithRows(){
		let tar = document.getElementById('mtable');
		for (let i=0;i<tar.dataset.rows;++i){
			createTableRow(tar.insertRow(-1),tar.dataset.cols, i);
		}
	}
	function sayRowCol(row,col){
		console.log(row,col);
	}

</script>

<script>
	'use strict';
	
	const ANALYZEARRAY = [];
	
	const can = document.getElementById('mines');
	const ctx = can.getContext('2d');

	const cellSize = Number(can.dataset.cellsize); // size of graphical cell in pixels
	const mwidth = can.width-(can.width%cellSize);
	const mheight = can.height-(can.height%cellSize);

	const mineNumberColors = ['gold','lime','aqua','fuchsia','orange','#111','#111','#111','#111','maroon'];
	const myfield = new Mines2d(mwidth/cellSize, mheight/cellSize, cellSize);
	
	const octx = osd.getContext('2d');
	octx.fillStyle = 'blue';
	octx.globalAlpha = 0.5;
	const osdSelection = new OsdSelection(myfield.rows, myfield.cols);
	osd.addEventListener('mousedown', function(e) {
		getCursorPosition(can, e);
	});
	osd.addEventListener('keydown', osdKeys);

	ctx.font = cellSize.toString()+'px monospace';
	ctx.textAlign = 'center';
	ctx.textBaseline = 'middle';
	ctx.strokeStyle = 'white';

	setupMinefield(myfield, Number(minecount.value));
	drawTileLines(mwidth,mheight,cellSize,'green');
	osdSelection.sq();
	osd.focus();
	mtable.dataset.rows = myfield.rows;
	mtable.dataset.cols = myfield.cols;
	mtable.dataset.mines = Number(minecount.value);
	fillTableWithRows();

</script>

</html>