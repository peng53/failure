<html>
<head>
<style>
	body {
		margin: 0;
	}
	canvas {
		position: absolute;
		top: 0;
		bottom: 0;
		left: 0;
		right: 0;
		margin: auto;
		border: 1px solid grey;
		image-rendering: crisp-edges;
		
		width: 300px;
		height: 300px;
		
	}
	#mines {
		z-index: -2;
	}
	#osd {
		z-index: -1;
		
	}
	#menu {
		margin: 0;
		padding: 0;
	}
	#menu button, #menu input{
		border: 0;
		float: left;
	}
	#menu button:hover {
		background: yellow;
	}
	#mtable {
		border: 1px orange solid;
		border-collapse: collapse;
		float: left;
	}
	#mtable td {
		font: 2em monospace;
		background: beige;
		width: 1em;
		height: 1em;
		text-align: center;
	}
	#mtable td:hover {
		background: cyan;
	}
</style>
</head>
<body>
<div id='menu'>
<button onclick='mcf.clearField()'>Clear</button>
<button onclick='revealField()'>RevealAll</button>
<input id='minecount' type='number' value=10 size=4 />
<button onclick='remine()'>Re-Mine</button>
<button onclick='osd.focus()'>Refocus</button>
<button onclick='mtable.style.display = "block";'>Enable Table</button>
</div>
<canvas
	id='mines'
	width='200px'
	height='200px'
	data-cellsize=20
	data-nmines=5
></canvas><canvas
	id='osd'
	width='200px'
	height='200px'
	tabindex= 1
></canvas>
<br>
<table id='mtable' data-rows=10 data-cols=10 data-mines=10 style='display:none'></table>
</body>
<script src='queue.js'></script>
<script>
	'use strict';
	/* primative internals */
	function Mines2d(cols, rows, cellSize){
		this.A = RectArray(rows,cols, 0);
		this.visible = RectArray(rows,cols, false);
		this.cols = cols;
		this.rows = rows;
		this.cellSize = cellSize;

		this.plantMine = function(r,c){
			this.A[r][c] = 9;
			let notTop = r>0, notLeft = c>0, notRight = c<this.cols, notBottom = r+1<this.rows;
			if (notTop){
				this.plantWarning(r-1,c);
				if (notLeft) this.plantWarning(r-1,c-1);
				if (notRight) this.plantWarning(r-1,c+1);
			}
			if (notBottom){
				this.plantWarning(r+1,c);
				if (notLeft) this.plantWarning(r+1,c-1);
				if (notRight) this.plantWarning(r+1,c+1);
			}
			if (notLeft) this.plantWarning(r,c-1);
			if (notRight) this.plantWarning(r,c+1);
		};

		this.plantWarning = function(r,c){
			if (this.A[r][c] !== 9){
				++this.A[r][c];
			}
		};
	}
	
	function ZeroLine(field, row, start, end){
		this.mf = field;
		this.r = row;
		this.c0 = start;
		this.c1 = (end===undefined) ? start : end;
		
		this.expand = function(match, adj){
			// Expands scanline on both sides.
			for (; this.c0-1>=0 && this.mf.A[this.r][this.c0-1] == match; --this.c0){
				continue;
			}
			for (; this.c1+1<this.mf.cols && this.mf.A[this.r][this.c1+1] == match; ++this.c1){
				continue;
			}
			return this;
		};
		this.reveal = function(revealEnds){
			// Reveals all tiles of this scanline.
			if (this.mf.visible[this.r][this.c0]) return;
			revealLine(this.r,this.c0,this.c1);
			if (revealEnds){
				if (this.c0>0) revealNumber(this.r,this.c0-1);
				if (this.c1+1<this.mf.cols) revealNumber(this.r,this.c1+1);
			}
		};
	}

	function getZeroLines(field, r, c0, c1, ifnot, out){
		if (r<0 || r>=field.rows) return;
		let start, end;
		for (let c=c0; c<=c1; ++c){
			if (field.visible[r][c]) continue;
			if (field.A[r][c] != 0){
				ifnot(r,c);
			} else {
				if (start === undefined){
					start = end = c;
				} else if (end+1==c){
					++end;
				} else {
					out.push(new ZeroLine(field, r, start, end));
					start = end = c;
				}
			}
		}
		if (end){
			out.push(new ZeroLine(field, r, start, end));
		}
	}




	function RectArray(rows, cols, v){
		const a = new Array(rows);
		for (let r = 0; r<rows; ++r){
			a[r] = ArrayWithValue(cols,v);
		}
		return a;
	}
	
	function ArrayWithValue(size, val){
		const a = new Array(size);
		for (let i=0;i<size;++i){
			a[i]=val;
		}
		return a;
	}
	

</script>

<script>
	'use strict';
	/* data setup */
	// Durstenfeld' shuffle
	function shuffleArray(A){
		let j,tempValue;
		for (let i=A.length-1; i>0; --i){
			j = Math.floor(Math.random()*i);
			tempValue = A[j];
			A[j] = A[i];
			A[i] = tempValue;
		}
	}
	function setupMinefield(mfield, mineCt){
		const mineLocLen = mfield.cols*mfield.rows;
		if (mineLocLen <= mineCt){
			alert('# of mines is equal or greater than dimensions');
			return;
		}
		const mineLoc = new Array(mineLocLen);
		// mineLoc is an Array of mine's priority
		for (let i=0; i<mineLoc.length; ++i){
			mineLoc[i] = i;
		}
		shuffleArray(mineLoc);
		
		let r, c;
		for (let i=0; i<mineCt; ++i){
			r = Math.floor(mineLoc[i] / mfield.cols);
			c = mineLoc[i] % mfield.cols;
			mfield.plantMine(r,c);
		}
	}
</script>

<script>
	'use strict';
	

	function MineCanvaFuncs(can, field, cellSize){
		this.can = can;
		this.ctx = ctx;
		this.sqSize = cellSize;
		this.off = cellSize/2;
		this.F = field;
		this.sq = function(x,y,cnt,color){
			this.ctx.fillStyle = color;
			this.ctx.fillRect(x,y,this.sqSize*cnt,this.sqSize);
		};
		this.tx = function(x,y,t){
			this.ctx.strokeText((t==9)? 'M' : t, x, y, this.sqSize);
		};
		this.revealTile = function(row, col){
			const x = this.sqSize * col;
			const y = this.sqSize * row;
			const t = this.F.A[row][col];
			this.sq(x,y,1,mineNumberColors[t]);
			this.tx(x+this.off,y+this.off,t);
		};
		this.revealLine = function(row, c0, c1){
			const t = this.F.A[row][c0];
			let y = this.sqSize*row;
			let x = this.sqSize*c0;
			this.sq(x, y, 1+c1-c0, mineNumberColors[t]);
			x += this.off;
			y += this.off;
			for (let c=c0;c<=c1;++c){
				this.tx(x,y,t);
				x += this.sqSize;
			}
		};
		this.tLines = function(color){
			for (let x=this.sqSize+1;x<this.can.width;x+=this.sqSize){
				this.ctx.moveTo(x,0);
				this.ctx.lineTo(x,this.can.height);
			}
			for (let y=this.sqSize+1;y<this.can.height;y+=this.sqSize){
				this.ctx.moveTo(0,y);
				this.ctx.lineTo(this.can.width,y);
			}
			this.ctx.strokeStyle = color;
			this.ctx.stroke();
		};
		this.drawState = function(){
			this.tLines('green');
			let x, y = 0, t;
			this.ctx.strokeStyle = 'white';
			for (let r=0;r<this.F.rows;++r){
				x = 0;
				for (let c=0;c<this.F.cols;++c){
					if (this.F.visible[r][c]){
						t = this.F.A[r][c];
						this.sq(x,y,1,mineNumberColors[t]);
						this.tx(x+this.off,y+this.off,t);
					}
					x += this.sqSize;
				}
				y += this.sqSize;
			}
		};
		this.clearField = function(){
			this.ctx.clearRect(0,0,this.can.width,this.can.height);
			this.F.A = RectArray(this.F.rows,this.F.cols, 0);
			this.F.visible = RectArray(this.F.rows,this.F.cols, false);
			this.tLines('green');
		};
	}

	/* drawing */

	function revealNumber(row,col){
		// temporary bridge
		myfield.visible[row][col] = true;
		mcf.revealTile(row,col);
	}
	function revealLine(row,c0,c1){
		// temporary bridge
		for (let c=c0;c<=c1;++c){
			myfield.visible[row][c] = true;
		}
		mcf.revealLine(row,c0,c1);
	}

	/* ui interaction */
	function getCursorPosition(canvas, event) {
		const rect = canvas.getBoundingClientRect();
		const x = event.clientX - rect.left;
		const y = event.clientY - rect.top;
		console.log(x,y);
		if (window.event.ctrlKey){
			XYtoCRcall(x,y, function(c, r){
				myfield.plantMine(r,c);
			});
		} else {
			XYtoCRcall(x,y, function(c, r){
				touchCanvas(r,c)
			});
		}
	}
	function XYtoCRcall(x,y,f){
		const sx = can.clientWidth/can.width;
		const sy = can.clientHeight/can.height;
		const c = Math.floor(x/(myfield.cellSize*sx));
		const r = Math.floor(y/(myfield.cellSize*sy));
		if (c < myfield.cols && r < myfield.rows){
			f(c,r);
		}
	}
	function touchCanvas(r,c){
		osdSelection.clear();
		osdSelection.r = r;
		osdSelection.c = c;
		osdSelection.sq();
		if (myfield.visible[r][c]){
			return;
		}
		if (myfield.A[r][c] == 0){
			floodReveal(r,c);
		} else {
			revealNumber(r,c);
		}
	}

	function floodReveal(row, col){
		// Reveal tiles around row, col- which is known to be not visible and a 0.
		//let q = new NaiveQueue();
		let q = new Queue();
		let s;
		q.push(new ZeroLine(myfield, row, col, col));
		while (q.len>0){
			s = q.get();
			s.expand(0);
			s.reveal(true);
			getZeroLines(myfield,s.r-1,s.c0,s.c1,revealNumber,q);
			getZeroLines(myfield,s.r+1,s.c0,s.c1,revealNumber,q);
		}
	}



	function revealField(){
		for (let r=0;r<myfield.rows;++r){
			for (let c=0;c<myfield.cols;++c){
				revealNumber(r,c);
			}
		}
	}
	function remine(){
		clearField();
		setupMinefield(myfield, Number(minecount.value));
		osd.focus();
	}
	

	/* osd stuff */
	function OsdSelection(rows, cols){
		this.mr = rows;
		this.mc = cols;
		this.r = 0;
		this.c = 0;
		this.sq = function(){
			const x = myfield.cellSize * this.c;
			const y = myfield.cellSize * this.r;
			octx.fillRect(x,y,myfield.cellSize,myfield.cellSize);
		};
		this.clear = function(){
			octx.clearRect(myfield.cellSize*this.c,myfield.cellSize*this.r,myfield.cellSize,myfield.cellSize);
		};
	}
	function osdKeys(ev){
		const key = ev.key;
		if (key == 'ArrowRight'){
			osdSelection.clear();
			osdSelection.c = (osdSelection.c+1)%osdSelection.mc;
			osdSelection.sq();
		} else if (key == 'ArrowLeft'){
			osdSelection.clear();
			osdSelection.c = (osdSelection.c-1>=0) ? osdSelection.c-1 : osdSelection.mc-1;
			osdSelection.sq();
		} else if (key == 'ArrowDown'){
			osdSelection.clear();
			osdSelection.r = (osdSelection.r+1)%osdSelection.mr;
			osdSelection.sq();
		} else if (key == 'ArrowUp'){
			osdSelection.clear();
			osdSelection.r = (osdSelection.r-1>=0) ? osdSelection.r-1 : osdSelection.mr-1;
			osdSelection.sq();
		} else if (key == 'Enter'){
			touchCanvas(osdSelection.r,osdSelection.c);
		} else if (key == 'r'){
			remine();
		}
	}
	
</script>

<script>
	'use strict';
	function setTableTileStates(field, tableMap){
		let t;
		for (let r=0;r<field.rows;++r){
			for (let c=0;c<field.cols;++c){
				if (field.visible[r][c]){
					t = field.A[r][c];
					//tableMap[r][c].style.backgroundColor = mineNumberColors[t];
					tableMap[r][c].style.setAttribute('background', mineNumberColors[t]);
					tableMap[r][c].textContent = (t==9) ? 'M' : t;
				}
			}
		}
	}
	function createTableRow(row, cols, rowNumber){
		let col;
		for (let i=0;i<cols;++i){
			col = row.insertCell(-1);
			col.append(document.createTextNode('?'));
			col.onclick = function(){touchCanvas(rowNumber,i)};
		}
		return row;
	}
	function fillTableWithRows(){
		let tar = document.getElementById('mtable');
		for (let i=0;i<tar.dataset.rows;++i){
			createTableRow(tar.insertRow(-1),tar.dataset.cols, i);
		}
	}
	function sayRowCol(row,col){
		console.log(row,col);
	}
	function mapTable(ele, rows, cols){
		// maps table to 2 index array
		let out = new Array(rows);
		for (let r=0;r<rows;++r){
			out[r] = new Array(cols);
			for (let c=0;c<cols;++c){
				out[r][c] =ele.childNodes[0].childNodes[r].childNodes[c];
			}
		}
		return out;
	}

</script>

<script>
	'use strict';
	
	const ANALYZEARRAY = [];
	
	const can = document.getElementById('mines');
	const ctx = can.getContext('2d');

	const cellSize = Number(can.dataset.cellsize); // size of graphical cell in pixels
	const mwidth = can.width-(can.width%cellSize);
	const mheight = can.height-(can.height%cellSize);

	const mineNumberColors = ['gold','lime','aqua','fuchsia','orange','#111','#111','#111','#111','maroon'];
	const myfield = new Mines2d(mwidth/cellSize, mheight/cellSize, cellSize);
	
	const octx = osd.getContext('2d');
	octx.fillStyle = 'blue';
	octx.globalAlpha = 0.5;
	const osdSelection = new OsdSelection(myfield.rows, myfield.cols);
	osd.addEventListener('mousedown', function(e) {
		getCursorPosition(can, e);
	});
	osd.addEventListener('keydown', osdKeys);

	ctx.font = cellSize.toString()+'px monospace';
	ctx.textAlign = 'center';
	ctx.textBaseline = 'middle';
	ctx.strokeStyle = 'white';



	setupMinefield(myfield, Number(minecount.value));
	const mcf = new MineCanvaFuncs(can,myfield,cellSize);
	mcf.tLines('green');
	osdSelection.sq();
	osd.focus();
	mtable.dataset.rows = myfield.rows;
	mtable.dataset.cols = myfield.cols;
	mtable.dataset.mines = Number(minecount.value);
	fillTableWithRows();
	let mtableCells = mapTable(mtable, myfield.rows, myfield.cols);


</script>

</html>