<html>
<style>
table {

}
td {
	text-align: center;
}
button {
	width: 30px;
	height: 30px;

}
.centerpiece {
	width: 100%;	
}
button[disabled] {
		color: #fff;
		border: none;
		background: none;
		display: blank;
}
</style>
<script>
'use strict';

// Durstenfeld' shuffle
function shuffleArray(A){
	let j,tempValue;
	for (let i=A.length-1; i>0; --i){
		j = Math.floor(Math.random()*i);
		tempValue = A[j];
		A[j] = A[i];
		A[i] = tempValue;
	}
}

class Piece {
	static Create(ele, value, callback, data, classes=[]){
		const h = document.createElement(ele);
		h.onclick = callback;
		h.textContent = value;
		for (const [datum,dval] of Object.entries(data)){
			h.dataset[datum] = dval;
		}
		for (const c of classes){
			h.classList.add(c);
		}
		return h;
	}
}


class Roto {
	static Numeric(rings,pieces){
		const p = Array.from(new Array(rings*pieces).keys()).map(e=>e+1);
		return new Roto(rings,pieces,0,p);
	}
	constructor(rings, slices_per_ring,empty_piece, pieces,classer=null){
		if (pieces.length<rings*slices_per_ring){
			throw new Error('Pieces count should match number of pieces!');
		}
		this.rings = rings;
		this.slices = slices_per_ring;
		this.ring = new Array(rings);
		this.emptyPiece = empty_piece;
		this.classer = classer;
		let callback = this.kbind.bind(this);
		for (let r=0; r<rings; ++r){
			this.ring[r] = new Array(slices_per_ring);
			for (let s=0; s<slices_per_ring; ++s){
				this.ring[r][s] = Piece.Create('button',pieces[(r*slices_per_ring)+s], callback, {ring:r, piece:s});
				if (this.classer){
					this.classer(this.ring[r][s]);
				}
			}
		}
		//this.center = 0; // 0 means the void
		this.center = Piece.Create('button',this.emptyPiece, callback, {ring:-1, piece:null,});
		this.center.disabled = true;
		this.freeRing = -1;
		this.freeSlice = null;
	}
	retext(list_rings){
		if (list_rings.length<this.rings*this.slices){
			throw new Error('Invalid Re-text values');
		} else {
			// should check whether center is clear before doing this
			for (let r=0;r<this.rings;++r){
				for (let s=0;s<this.slices;++s){
					this.ring[r][s].textContent = list_rings[r*this.slices+s];
				}
			}
		}
	}
	kbind(ev){
		this.move(ev.target.dataset.ring,ev.target.dataset.piece);
	}
	move(ring,piece=null){
		// where ring,piece describe the piece being moved
		const movingPiece = (ring==-1) ? this.center : this.ring[ring][piece];
		const freePiece = (this.freeRing==-1) ? this.center : this.ring[this.freeRing][this.freeSlice];
		if ((ring==-1 && this.freeRing==0) // center to 0 ring
		|| (ring==0 && this.freeRing==-1) // 0 ring to center
		|| (ring==this.freeRing && (Math.abs(piece-this.freeSlice)==(this.slices-1) || Math.abs(piece-this.freeSlice)==1))  // same ring shift
		|| (piece==this.freeSlice && Math.abs(ring-this.freeRing)==1) // adj ring same slice
		){
			[movingPiece.textContent,freePiece.textContent] = [freePiece.textContent, movingPiece.textContent]
			movingPiece.disabled = true;
			freePiece.disabled = false;
			this.freeRing = ring;
			this.freeSlice = piece;
			if (this.classer){
				this.classer(freePiece);
				movingPiece.style.color= null;
			}
		} else {
			throw new Error('Illegal Move');
		}
	}
}
</script>
<body>
<table id='rototable'>
</table>
</body>
<script>
{
	const rings = 4;
	const slices = 4;
	const classer = function(b){
		const suit = (b.textContent).toString().substr(1);
		switch (suit){
			case '♥':
				b.style.color = 'red';
				break;
			case '♦':
				b.style.color = 'maroon';
				break;
			case '♠':
				b.style.color = 'black';
				break;
			case '♣':
				b.style.color = 'green';
				break;
			default:
				break;
		}
	};
	const mypieces = ['A♠','2♠','3♠','4♠','A♥','2♥','3♥','4♥','A♦','2♦','3♦','4♦','A♣','2♣','3♣','4♣'];
	shuffleArray(mypieces);
	const x = new Roto(rings,slices,'JK',mypieces,classer);
	//const x = Roto.Numeric(rings,slices);

	let row = rototable.insertRow(-1);
	{
		row.insertCell(-1).textContent = 'C';
		let xcen = row.insertCell(-1);
		x.center.classList.add('centerpiece');
		xcen.appendChild(x.center);
		xcen.colSpan = slices;
	}

	for (let r=0;r<x.rings;++r){
		row = rototable.insertRow(-1);
		row.insertCell(-1).textContent = r;
		for (let s=0;s<x.slices;++s){
			row.insertCell(-1).appendChild(x.ring[r][s]);
		}
	}
}
</script>
</html>
