<html>
<style>
table {

}
td {
	text-align: center;
}
button {
	width: 30px;
	height: 30px;

}
.centerpiece {
	width: 100%;	
}
button[disabled] {
		color: #fff;
		border: none;
		background: none;
		display: blank;
}
</style>
<script>
'use strict';

class Piece {
	static Create(ele, value, callback, data){
		const h = document.createElement(ele);
		h.onclick = callback;
		h.textContent = value;
		for (const [datum,dval] of Object.entries(data)){
			h.dataset[datum] = dval;
		}
		return h;
	}
}


class Roto {
	constructor(rings, slices_per_ring,empty_piece='O'){
		this.rings = rings;
		this.slices = slices_per_ring;
		this.ring = new Array(rings);
		this.emptyPiece = empty_piece;
		let callback = this.kbind.bind(this);
		for (let r=0; r<rings; ++r){
			this.ring[r] = new Array(slices_per_ring);
			for (let s=0; s<slices_per_ring; ++s){
				this.ring[r][s] = Piece.Create('button',(r*slices_per_ring)+s+1, callback, {ring:r, piece:s});
			}
		}
		//this.center = 0; // 0 means the void
		this.center = Piece.Create('button',this.emptyPiece, callback, {ring:-1, piece:null,});
		this.center.disabled = true;
		this.freeRing = -1;
		this.freeSlice = null;
	}
	retext(list_rings){
		if (list_rings.length!=this.rings*this.slices){
			return new Error('Invalid Re-text values');
		} else {
			// should check whether center is clear before doing this
			for (let r=0;r<this.rings;++r){
				for (let s=0;s<this.slices;++s){
					this.ring[r][s].textContent = list_rings[r*this.slices+s];
				}
			}
		}
	}
	kbind(ev){
		this.move(ev.target.dataset.ring,ev.target.dataset.piece);
	}
	move(ring,piece=null){
		// where ring,piece describe the piece being moved
		const movingPiece = (ring==-1) ? this.center : this.ring[ring][piece];
		const freePiece = (this.freeRing==-1) ? this.center : this.ring[this.freeRing][this.freeSlice];
		let moveOk = false;
		if (ring==-1){ // the center was chosen
			if (this.center!=this.emptyPiece && this.freeRing==0 && this.freeSlice!=null){
				// the center can only be chosen if the free spot is on the adj ring
				moveOk = true;
			}
		} else { // a piece on a ring
			if (this.center.textContent==this.emptyPiece && ring==0){ // the free spot on center is adj to selected ring
				moveOk = true;
			} else if (ring==this.freeRing && (Math.abs(piece-this.freeSlice)==(this.slices-1) || Math.abs(piece-this.freeSlice)==1)){
				moveOk = true;
			} else if (piece==this.freeSlice &&Math.abs(ring-this.freeRing)==1){
				// move to adj ring
				moveOk = true;
			} else {
				return new Error('Illegal Move');
			}
		}
		if (moveOk){
			[movingPiece.textContent,freePiece.textContent] = [freePiece.textContent, movingPiece.textContent]
			movingPiece.disabled = true;
			freePiece.disabled = false;
			this.freeRing = ring;
			this.freeSlice = piece;
		}
	}
}
</script>
<body>
<table id='rototable'>
</table>
</body>
<script>
const rings = 3;
const slices = 5;
const x = new Roto(rings,slices);

let row = rototable.insertRow(-1);
{
	row.insertCell(-1).textContent = 'C';
	let xcen = row.insertCell(-1);
	x.center.classList.add('centerpiece');
	xcen.appendChild(x.center);
	xcen.colSpan = slices;
}

for (let r=0;r<x.rings;++r){
	row = rototable.insertRow(-1);
	row.insertCell(-1).textContent = r;
	for (let s=0;s<x.slices;++s){
		row.insertCell(-1).appendChild(x.ring[r][s]);
	}
}
</script>
</html>
