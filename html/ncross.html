<html>
<body>
<canvas id='ncan' width=600 height=600 style='border:1px solid red;' data-hintreserve=100 data-fontsize=16 data-rows=10 data-cols=10 ></canvas>
<br /><input id='hintsSpace' value='100' onblur='hintReserveResize(event.target.value);' />
<div>
<input class='c' />x<input class='r' />
<br/><button onclick='setNboardSize(this.parentElement)'>Set Nboard</button>
</div>
</body>
<script>
class MouseClick {
	constructor(x,y){
		this.x = x;
		this.y = y;
	}
}

function SetLastClick(event){
	event.target.lastclick = new MouseClick(event.offsetX,event.offsetY);
}

ncan.lastclickToRC = function(board){
	const hintReserve = parseInt(this.dataset['hintreserve']);
	const twidth = (this.width-hintReserve)/(board.width);
	const theight = (this.height-hintReserve)/(board.height);
	const x = this.lastclick.x-hintReserve;
	const y = this.lastclick.y-hintReserve;
	if (x>=0 && y>=0) return {c : Math.floor(x/twidth), r : Math.floor(y/theight)};
}

ncan.drawBoard = function(board){
	const ctx = this.getContext('2d');
	ctx.fillStyle = 'red';
	ctx.clearRect(0,0,ncan.width,ncan.height);
	ctx.font = `${this.dataset['fontsize']}px Arial`;
	const hintReserve = parseInt(this.dataset['hintreserve']);
	const twidth = (this.width-hintReserve)/(board.width);
	const theight = (this.height-hintReserve)/(board.height);
	for (let r=0;r<board.height;++r){
		for (let c=0;c<board.width;++c){
			if (board.A[r][c]==1){
				ctx.fillRect(c*twidth+hintReserve,r*theight+hintReserve,twidth,theight);
			}
		}
	}
	const fontlb = parseInt(this.dataset['fontsize']);
	ctx.textAlign = 'left';
	ctx.textBaseline = 'middle';
	for (let r=0;r<board.height;++r){
		for (let i=0;i<board.rowHints[r].length;++i){
			ctx.strokeText(board.rowHints[r][i], i*fontlb, r*theight+theight/2+hintReserve);
		}
	}
	ctx.textAlign = 'center';
	ctx.textBaseline = 'top';
	for (let c=0;c<board.width;++c){
		for (let i=0;i<board.colHints[c].length;++i){
			ctx.strokeText(board.colHints[c][i], c*twidth+hintReserve+twidth/2, i*fontlb);
		}
	}
	this.drawLines(hintReserve,board.height,theight, board.width, twidth);
};
ncan.drawLines = function(hintReserve,rows,theight,cols,twidth){
	const ctx = this.getContext('2d');
	ctx.strokeStyle = 'black';
	ctx.beginPath();
	for (let r=0;r<rows;++r){
		ctx.moveTo(0,hintReserve+r*theight);
		ctx.lineTo(this.width,hintReserve+r*theight);
	}
	for (let c=0;c<cols;++c){
		ctx.moveTo(hintReserve+c*twidth, 0);
		ctx.lineTo(hintReserve+c*twidth, this.height);
	}
	ctx.stroke();
	ctx.closePath();
}


function hintReserveResize(newr){
	if (newr!=ncan.dataset['hintreserve']){
		ncan.dataset['hintreserve'] = newr;
		ncan.drawBoard(x);
	}
}

function getRandomIntInclusive(min, max) {
	min = Math.ceil(min);
	max = Math.floor(max);
	return Math.floor(Math.random() * (max - min + 1) + min); //The maximum is inclusive and the minimum is inclusive
}
class NCrossBoard {
	constructor(width, height){
		this.width = width;
		this.height = height;
		this.clear();
	}
	clear(){
		this.A = [];
		this.rowHints = [];
		for (let r=0;r<this.height;++r){
			this.A[r] = new Uint8Array(this.width);
			this.A[r].fill(0);
			this.rowHints.push([]);
		}
		this.colHints = [];
		for (let c=0;c<this.width;++c){
			this.colHints.push([]);
		}
	}
	recalcRow(r){
		let hint = [];
		for (let c=0;c<this.width;++c){
			if (this.A[r][c]==1){ // if this tile is filled..
				if (c>0 && this.A[r][c-1]==1){ // and the previous adjacent one was filled
					// then use the most current 'hint bar'
					hint[hint.length-1] += 1;
				} else { // otherwise create a new one
					hint.push(1);
				}
			}
		}
		this.rowHints[r] = hint;
	}
	recalcCol(c){
		let hint = [];
		for (let r=0;r<this.height;++r){
			if (this.A[r][c]==1){ // if this tile is filled..
				if (r>0 && this.A[r-1][c]==1){ // and the previous adjacent one was filled
					// then use the most current 'hint bar'
					hint[hint.length-1] += 1;
				} else { // otherwise create a new one
					hint.push(1);
				}
			}
		}
		this.colHints[c] = hint;
	}
	generate(){
		for (let r=0;r<this.height;++r){
			for (let c=0;c<this.width;++c){
				this.A[r][c] = getRandomIntInclusive(0,1);
			}
			this.recalcRow(r);
		}
		for (let c=0;c<this.width;++c){
			this.recalcCol(c);
		}
	}
}
function setNboardSize(p){
	const c = p.querySelector('.c').value;
	const r = p.querySelector('.r').value;
	if (c!=ncan.dataset['cols'] || r!=ncan.dataset['rows']){
		ncan.dataset['cols'] = c;
		ncan.dataset['rows'] = r;
		x = new NCrossBoard(c,r);
		x.generate();
		ncan.drawBoard(x);
	}
}

let rows = parseInt(ncan.dataset['rows']);
let cols = parseInt(ncan.dataset['cols']);
let x = new NCrossBoard(cols,rows);
x.generate();
console.table(x.A);
console.log(x.colHints);
console.log(x.rowHints);
ncan.drawBoard(x);
ncan.addEventListener('click',SetLastClick);
ncan.addEventListener('click',(e)=>e.target.lastclickToRC(x));
</script>
</html>