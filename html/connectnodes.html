<html>
<style>
	body { margin: 0;}
</style>
<canvas id='cnodes' width=auto height=auto ></canvas>
<script src='distRamp.js'></script>

<script>
	'use strict';
	function CanvasGrid(width, height, rows){
		this.cellWidth = width/rows.length;
		this.height = height;
		this.rows = rows;
	}
	CanvasGrid.prototype.rect = function(i,j){
		const cellHeight = this.height/this.rows[i];
		return [i*this.cellWidth, j*cellHeight, this.cellWidth, cellHeight];
	};

	function MappedNode(val, color, i, j){
		this.val = val;
		this.color = color;
		this.i = i;
		this.j = j;
	}

	function SpecialNode(n){
		this.n = n;
		this.col = getRandomColor2();
	}
	function getRandomInt(min, max) {
		min = Math.ceil(min);
		max = Math.floor(max);
		return Math.floor(Math.random() * (max - min)) + min; //The maximum is exclusive and the minimum is inclusive
	}
	function getRandomColor2(){
		return 'rgb('+getRandomInt(0,256).toString()+','+getRandomInt(0,256).toString()+','+getRandomInt(0,256).toString()+')';
	}

	cnodes.width = window.innerWidth;
	cnodes.height = window.innerHeight;
	
	cnodes.drawNode = function(node, drawer, sizeMultipier){
		const ctx = this.getContext('2d');
		const [x,y,w,h] = drawer.rect(node.i,node.j);
		//const xM = Math.min(w,h)*sizeMultipier;
		const xM = Math.min(h,w)*sizeMultipier;
		ctx.fillStyle = node.color;
		ctx.beginPath();
		//ctx.strokeRect(x,y,w,h);
		ctx.arc(x+(w/2),y+(h/2),xM/2,0,2*Math.PI);
		ctx.fill();
		ctx.font = (xM/2).toString()+'px monospace';
		ctx.strokeText(node.val, x+w/2, y+h/2);
	};
	cnodes.traceNodes = function(node1, node2, drawer){
		const ctx = this.getContext('2d');
		const [x1,y1,w1,h1] = drawer.rect(node1.i,node1.j);
		const [x2,y2,w2,h2] = drawer.rect(node2.i,node2.j);
		const col = ctx.createLinearGradient(x1+w1/2,y1+h1/2,x2+w2/2,y2+h2/2);
		col.addColorStop(0,node1.color);
		col.addColorStop(0.5,node2.color);
		ctx.beginPath();
		ctx.moveTo(x1+w1/2,y1+h1/2);
		if (node1.i==node2.i && Math.abs(node1.j-node2.j)>1){
			const midpt = (y2-y1)/2;
			ctx.bezierCurveTo(
				x1,y1+(h1/2)+midpt,
				x1,y2+(h2/2)-midpt,
				x2+w2/2,y2+h2/2
			);
		} else {
			ctx.lineTo(x2+w2/2,y2+h2/2);
		}
		ctx.strokeStyle = col;
		ctx.stroke();
	};
	const colCount = 3;
	const nodeCount = 30;
	const nodes = new Array(nodeCount);
	const dist = new RampDist(colCount);
	const ctx = cnodes.getContext('2d');
	ctx.textAlign = 'center';
	ctx.textBaseline = 'middle';
	ctx.lineWidth = 1.5;
	nodes[0] = new MappedNode('a', getRandomColor2(), 0, 0);
	nodes[1] = new MappedNode('b', getRandomColor2(), 1, 0);
	nodes[2] = new MappedNode('c', getRandomColor2(), 0, 1);
	
	/*{
		let r, c;
		for (let i=0; i < nodeCount; ++i){
			[r,c] = dist.get();
			nodes[i] = new MappedNode(i, getRandomColor2(), r, c);
		}
	}*/
	//const drawer = new CanvasGrid(cnodes.width, cnodes.height, dist.rows);
	const drawer = new CanvasGrid(cnodes.width, cnodes.height, [2,1,0]);
	/*{
		let j;
		for (let i=0;i<nodeCount;++i){
			j = getRandomInt(0, nodeCount);
			console.log(i,j);
			cnodes.traceNodes(nodes[i], nodes[j], drawer);
		}
	}
	ctx.strokeStyle = 'black';
	for (let i=0; i < nodeCount; ++i){
		cnodes.drawNode(nodes[i], drawer, 0.4);
	}*/
	cnodes.traceNodes(nodes[0], nodes[1], drawer);
	cnodes.traceNodes(nodes[1], nodes[2], drawer);
	ctx.strokeStyle = 'black';
	cnodes.drawNode(nodes[0], drawer, 0.4);
	cnodes.drawNode(nodes[1], drawer, 0.4);
	cnodes.drawNode(nodes[2], drawer, 0.4);

	/*
	
	
	let rcols = new RampCols(colCount);
	let node;
	const nodeRegistry = new Array(nodeCount);
	for (let i=0;i<nodeCount;++i){
		node = new SpecialNode(i);
		nodeRegistry[i] = rcols.ins(node);
	}
	cnodes.drawCol = function(colNum, col){
		const ctx = this.getContext('2d');
		const cellHeight = (this.height)/(col.length);

		let x,y;
		for (let i=0;i<col.length;++i){
			x = colNum*this.colWidth+this.colWidth/2;
			y = i*cellHeight+cellHeight/2;
			ctx.beginPath();
			ctx.arc(x, y, 15, 0, 2*Math.PI);
			ctx.fillStyle = col[i].col;
			ctx.fill();
			ctx.strokeText(col[i].n, x, y);
		}
	};
	cnodes.tracePts = function(r0,c0,col0L,r1,c1,col1L, colorr){
		const ctx = this.getContext('2d');
		const cellHeight0 = (this.height)/(col0L);
		const cellHeight1 = (this.height)/(col1L);
		const x0 = r0*this.colWidth+this.colWidth/2;
		const y0 = c0*cellHeight0+cellHeight0/2;
		const x1 = r1*this.colWidth+this.colWidth/2;
		const y1 = c1*cellHeight1+cellHeight1/2;
		const col = ctx.createLinearGradient(x0,y0,x1,y1);
		col.addColorStop(0,colorr[0]);
		col.addColorStop(0.5,colorr[1]);
		ctx.beginPath();
		ctx.moveTo(x0,y0);
		ctx.lineTo(x1,y1);
		ctx.strokeStyle = col;
		ctx.stroke();
	};
	cnodes.traceBezierPts = function(r,c0,c1,colL, colorr){
		const ctx = this.getContext('2d');
		const cellHeight0 = (this.height)/(colL);
		const x0 = r*this.colWidth+this.colWidth/2;
		const y0 = c0*cellHeight0+cellHeight0/2;
		const y1 = c1*cellHeight0+cellHeight0/2;
		const col = ctx.createLinearGradient(x0,y0,x0,y1);
		const midpt = (y1-y0)/3;
		col.addColorStop(0,colorr[0]);
		col.addColorStop(0.5,colorr[1]);
		ctx.beginPath();
		ctx.moveTo(x0,y0);
		ctx.bezierCurveTo(x0-(this.colWidth/2),y0+midpt,x0-(this.colWidth/2),y0+2*midpt, x0,y1);
		ctx.strokeStyle = col;
		ctx.stroke();
	}
	cnodes.colWidth = cnodes.width/colCount;

	let p, r, c, r1, c1;
	for (let i=0;i<nodeCount;++i){
		p = getRandomInt(0,nodeCount);
		if (i==p) continue;
		
		[r,c] = nodeRegistry[i];
		[r1,c1] = nodeRegistry[p];

		console.log(i,'to',p);
		if (r==r1 && Math.abs(c1-c)>1){
		cnodes.traceBezierPts(r,c,c1,rcols.cols[r].length,
			[rcols.cols[r][c].col, rcols.cols[r1][c1].col]);
		} else {
		cnodes.tracePts(r,c,rcols.cols[r].length,
			r1,c1,rcols.cols[r1].length,
			[rcols.cols[r][c].col, rcols.cols[r1][c1].col]);
		}
	}
	for (let i=0;i<colCount;++i){
		cnodes.drawCol(i, rcols.cols[i]);
	}

	*/
</script>
</html>
