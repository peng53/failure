<html>
<style>
	body {
		margin: 0;
	}
	canvas {

	}
</style>

<canvas id='mycan' width='400px' height='300px'></canvas>

<script>
	function transformX(x, scale, xOffset){
		// Transforms to pixel coord
		return scale * (x-xOffset);
	}
	function transformY(y, scale, yOffset){
		// Transforms to pixel coord
		return scale * (yOffset-y);
	}
	function calculateScale(view, outputLength){
		return outputLength / Math.abs(view[1] - view[0]);
	}

	function circlePtAt(ctx,x,y){
		//ctx.beginPath();
		ctx.arc(x,y,1,0,2* Math.PI);
		//ctx.stroke();
	}

	function originLines(xscale, xview, yscale, yview, can){
		let ctx = can.getContext('2d');
		ctx.setLineDash([]);
		ctx.strokeStyle = 'red';
		ctx.beginPath();
		// line x = 0
		let x0 = transformX(0, xscale, xview[0]);
		ctx.moveTo(x0,0);
		ctx.lineTo(x0, can.height);
		ctx.stroke();
		// line y = 0
		let y0 = transformY(0, yscale, yview[1]);
		ctx.moveTo(0,y0);
		ctx.lineTo(can.width, y0);
		ctx.stroke();
	}
	function gridLines(xscale, xview, xinterval, yscale, yview, yinterval, can){
		let ctx = can.getContext('2d');
		let x0 = transformX(0, xscale, xview[0]);
		let y0 = transformY(0, yscale, yview[1]);
		let dy = yinterval*yscale;

		ctx.setLineDash([3,2]);
		ctx.strokeStyle = 'lime';
		for (let y=y0-dy; y>0; y-=dy){
			ctx.beginPath();
			ctx.moveTo(0,y);
			ctx.lineTo(can.width, y);
			ctx.stroke();
		}
		for (let y=y0+dy; y<can.height; y+=dy){
			ctx.beginPath();
			ctx.moveTo(0,y);
			ctx.lineTo(can.width, y);
			ctx.stroke();
		}

		let dx = xinterval*xscale;
		ctx.setLineDash([2,3]);
		ctx.strokeStyle = 'teal';
		for (let x=Math.ceil(xview[0]/xinterval)*xscale; x<can.width; x+= dx){
			ctx.beginPath();
			ctx.moveTo(x,0);
			ctx.lineTo(x,can.height);
			ctx.stroke();
		}
	}

	function plotPoints(points, xscale, yscale, xview, yview, can){
		let ctx = can.getContext('2d');
		let x, y;
		ctx.fillStyle = 'blue';
		ctx.beginPath();
		for (let i=0, l=points.length; i<l; ++i){
			x = transformX(points[i].x, xscale, xview[0]);
			y = transformY(points[i].y, yscale, yview[1]);
			circlePtAt(ctx,x,y);
		}
		ctx.setLineDash([]);
		ctx.strokeStyle = 'black';
		ctx.stroke();
	}

	function getMinAndMax(values, getter){
		let m = getter(values[0]);
		let M = m;
		let v;
		for (let i=1; i<values.length; ++i){
			v = getter(values[i]);
			if (v<m){
				m = v;
			} else if (v>M){
				M = v;
			}
		}
		return [m, M];
	}

	function Point(x,y){
		this.x = x;
		this.y = y;
	}
	function canvasBg(can){
		let ctx = can.getContext('2d');
		ctx.fillStyle = 'white';
		ctx.rect(0,0,can.width, can.height);
		ctx.fill();
	}

	function sortedPointArray(xvals, yvals){
		let points = Array();
		for (let i=0, l=xvals.length; i<l; ++i){
			points.push(new Point(xvals[i],yvals[i]));
		}
		points.sort((a,b) => a.x-b.x);
		return points;
	}

	let points = sortedPointArray(
		xvals = Array(-4,-3,-2,-1,0,1,2,3,4),
		yvals = Array(-64,-27,-8,-1,0,1,8,27,64)
	);

	let xview = [points[0].x, points[points.length-1].x];
	let yview = getMinAndMax(points, (point) => point.y);

	let can = document.getElementById('mycan');
	let xscale = calculateScale(xview, can.width);
	let yscale = calculateScale(yview, can.height);
	
	canvasBg(can);
	gridLines(xscale, xview, xinterval=1, yscale, yview, yinterval=5, can);
	originLines(xscale, xview, yscale, yview, can);
	plotPoints(points, xscale, yscale, xview, yview, can);

</script>
</html>

